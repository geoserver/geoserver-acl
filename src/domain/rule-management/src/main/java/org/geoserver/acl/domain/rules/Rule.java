/* (c) 2023  Open Source Geospatial Foundation - all rights reserved
 * This code is licensed under the GPL 2.0 license, available at the root
 * application directory.
 *
 * Original from GeoFence 3.6 under GPL 2.0 license
 */

package org.geoserver.acl.domain.rules;

import lombok.Builder;
import lombok.Builder.Default;
import lombok.NonNull;
import lombok.Value;
import lombok.With;

/**
 * Data access control rule for GeoServer resources.
 *
 * <p>Defines who can access what GeoServer resources (workspaces, layers, services) and what level
 * of access they have (allow, deny, or limit).
 *
 * <p>Rules are evaluated in strict priority order (lower numbers first). The first matching rule
 * determines the access decision. Example:
 * <pre>{@code
 * Priority 1: username="alice", workspace="topp", layer="states" -> ALLOW
 * Priority 2: username="alice", workspace="topp" -> DENY
 * Priority 3: username="alice" -> ALLOW
 * }</pre>
 * When alice requests "topp:states", Rule 1 matches first and grants access. For "topp:roads",
 * Rule 2 matches and denies access.
 *
 * <p>Components:
 * <ul>
 *   <li>{@link RuleIdentifier}: Matching criteria (user, role, IP, service, workspace, layer)
 *   <li>{@link GrantType}: Access type (ALLOW, DENY, LIMIT)
 *   <li>{@link RuleLimits}: Restrictions for LIMIT rules (spatial constraints, catalog mode)
 *   <li>{@link LayerDetails}: Detailed permissions for ALLOW rules (CQL filters, styles, attributes)
 * </ul>
 *
 * <p>Priority is a {@code long} where lower numbers = higher priority. No two rules can have the
 * same priority. {@link RuleAdminService} can automatically shift priorities to maintain uniqueness.
 *
 * <p>Examples:
 * <pre>{@code
 * // ALLOW rule
 * Rule allowRule = Rule.allow()
 *     .withUsername("alice")
 *     .withWorkspace("topp")
 *     .withPriority(100);
 *
 * // DENY rule
 * Rule denyRule = Rule.deny()
 *     .withUsername("bob")
 *     .withWorkspace("topp")
 *     .withLayer("classified")
 *     .withPriority(50);
 * }</pre>
 *
 * <p>Immutable. Use {@code with*()} methods or {@code toBuilder()} for modifications.
 *
 * @since 1.0
 * @see RuleIdentifier
 * @see GrantType
 * @see RuleLimits
 * @see LayerDetails
 */
@Value
@With
@Builder(toBuilder = true, builderClassName = "Builder")
public class Rule {

    private static final RuleIdentifier EMPTY_IDENTIFIER =
            RuleIdentifier.builder().build();

    /**
     * Unique internal identifier for this rule.
     *
     * <p>Generated by the repository on rule creation. Can be {@code null} for transient (unsaved)
     * rules.
     */
    private String id;

    /**
     * External identifier for integration with other systems.
     *
     * <p>This field allows external systems to reference rules using their own identifier schemes,
     * simplifying integration in complex environments where rules may be managed across multiple
     * systems.
     */
    private String extId;

    /** Human-readable name for the rule. Optional. */
    private String name;

    /** Description explaining the purpose of this rule. Optional. */
    private String description;

    /**
     * Priority determines evaluation order (lower values = higher priority).
     *
     * <p>Rules are evaluated in strict priority order. The first rule matching all request
     * criteria determines the access decision. Priority must be unique across all rules.
     */
    private long priority;

    /**
     * Rule matching criteria and access grant type.
     *
     * <p>Defines which requests this rule applies to (username, role, IP, service, workspace,
     * layer) and what access it grants (ALLOW, DENY, or LIMIT).
     */
    @NonNull
    @Default
    private RuleIdentifier identifier = EMPTY_IDENTIFIER;

    /**
     * Optional restrictions for LIMIT grant type rules.
     *
     * <p>Only applicable when {@code identifier.access} is {@link GrantType#LIMIT}. Specifies
     * spatial constraints and catalog visibility mode.
     *
     * @see RuleLimits
     */
    private RuleLimits ruleLimits;

    public @Override String toString() {
        return "Rule[id: %s, %s]".formatted(id, toShortString());
    }

    public GrantType access() {
        return getIdentifier().getAccess();
    }

    public String ipAddressRange() {
        return getIdentifier().getAddressRange();
    }

    public Rule withUsername(String username) {
        return withIdentifier(identifier.withUsername(username));
    }

    public Rule withRolename(String rolename) {
        return withIdentifier(identifier.withRolename(rolename));
    }

    public Rule withService(String service) {
        return withIdentifier(identifier.withService(service));
    }

    public Rule withAddressRange(String addressRange) {
        return withIdentifier(identifier.withAddressRange(addressRange));
    }

    public Rule withRequest(String request) {
        return withIdentifier(identifier.withRequest(request));
    }

    public Rule withSubfield(String subfield) {
        return withIdentifier(identifier.withSubfield(subfield));
    }

    public Rule withWorkspace(String workspace) {
        return withIdentifier(identifier.withWorkspace(workspace));
    }

    public Rule withLayer(String layer) {
        return withIdentifier(identifier.withLayer(layer));
    }

    public Rule withAccess(GrantType access) {
        return withIdentifier(identifier.withAccess(access));
    }

    public static Rule allow() {
        return Rule.builder().build().withAccess(GrantType.ALLOW);
    }

    public static Rule deny() {
        return Rule.builder().build().withAccess(GrantType.DENY);
    }

    public static Rule limit() {
        return Rule.builder().build().withAccess(GrantType.LIMIT);
    }

    public String toShortString() {
        return "priority: %d, %s".formatted(getPriority(), getIdentifier().toShortString());
    }
}
